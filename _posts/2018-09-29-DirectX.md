---
layout: post
title: "DirectX정리중"
description: DirectX
image: '\images\driectx.png'
category: 'Shader'
tag:
 - HLSL
introduction: DirectX정리중
---



#  Shader Post Effect 

포스트 이펙트란 렌더링이 완료된 화면에 인위적인 효과를 첨가하여 다른 분위기로 변환돈 화면을 만드는 기술

을 말합니다



# 흐림 필터

1. 선형 텍스처 필터링(linear texture filtering)
2. 쌍선형 필터링(bilinear filtering)
3. 9콘 필터 샘플링
4. 64박스 필터 샘플링
5. 가우스필터





VS2010팀블로그 강좌 : <http://vsts2010.tistory.com/112?category=128642>

같은사이트 알콜코더님 포스팅 : <http://vsts2010.tistory.com/447?category=128642>

해외 유명한 튜토리얼 : <http://www.rastertek.com/tutindex.html>

어떤분이 번역해주셨네요 : <http://copynull.tistory.com/237?category=649932



```c++
struct VS_OUTPUT{
    float4 Pos : POSITION;
    float2 Tex : TEXCOORD0;
};

VS_OUTPUT VS(float4 Pos : POSITION, float2 Tex : TEXCOORD0){
    VS_OUTPUT Out = (VS_OUTPUT)0; //출력데이터
    Out.Pos = mul(Pos, mWVP);
    Out.Tex = Tex;
    return Out;
}

//픽셀 셰이더에서 그냥 색상으로 출력할때는 COLOR를 붙여주고
//픽셀 셰이더에서 복수 출력을 할떄에는 정점셰이더와 같은 구조체를 정의해서 출력한다
float4 PS (VS_OUTPUT In) : COLOR{
    return tex2D(Samp, In.Tex);
}

//=======================
//테크닉
//=======================
technique TShdaer{
    pass P0{
        //셰이더
        VertexShader = complie vs_1_1 VS();
        PixelShader = complie ps_1_1 PS();
    }
}

//다중 패스를 사용할때
technique TSahder2Pass{
    pass P0{
        VertexShader = complie vs_1_1 VS0();
        PixelShader = complie ps_1_1 PS0();
    }
    
    pass P1{
        VertexShader = complie vs_1_1 VS1();
        PixelShader = complie ps_1_1 PS1();
    }
}
```

라이팅 모델 = 환경광 + 확산반사광  (기본적으로 많이 쓰이는 라이팅모델)

```c++
float4x4 mWVP;
float4z4 mWIT;

float3 vLightDir;

//광원 밝기
float4 I_a = {0.3f, 0.3f, 0.3f, 0.0f}; // ambient
flaot4 I_d = {0.7f, 0.7f, 0.7f, 0.0f}; //diffuse;

//반사율
float4 k_a = {1.0f, 1.0f, 1.0f, 1.0f};
float4 k_d = {1.0f, 1.0f, 1.0f, 1.0f};

VS_OUTPUT VS{
    float4 Pos : POSITION;
    float4 Color : COLOR0;
    float3 Normal : NORMAL;    
};

VS_OUTPUT VS(float4 Pos : POSITION, float3 Normal : NORMAL){
    VS_OUTPUT Out = (VS_OUTPUT)0;
    
    float3 L = -vLightDir;
    float3 N = normalize(mul(Normal, (float3x3)mWIT)); //월드좌표에서 법선
    
    Out.Color = I_a *k_a + I_d * k_d * max(0, dot(N, L));
    
    return Out;
}

float4 PS(VS_OUTPUT In) : COLOR{
    return In.Color;
}
```

