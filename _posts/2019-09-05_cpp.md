---
layout: post
title: "cpp"
description: cpp
image: '\images\bg.jpg'
category: 'cpp'
tag:
 - cpp
introduction: cpp정리중...
---



# CPP



|                            C언어                             |                             C++                              |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| c언어는 절차지향적 언어이다. 다형성, 캡슐화, 상속 등을 사용할 수 없다 |                c++언어는 개체지향적 언어이다.                |
|                 c언어는 중간 수준 언어이다.                  |                   c++언어는 고급 언어이다.                   |
| c언어를 c++의 부분집합으로 보는 견해도 있으나 일부 다른 부분도 있다. | c함수 사용가능, reference, namespace, 예외처리 등은 c++에서 가능 |
|              구조체 안에 함수가 정의될 수 없다.              |              구조체 안에 함수가 정의될 수 있다.              |
|     동적 메모리 관리에 malloc, calloc/free 등을 사용한다     |                    new /deletet 사용한다                     |
|  iostream을 사용할 수 없고 printf, scanf등으 주로 사용한다.  | iostream을 이용해서 cosole, file, network IO를 일원화 할수 있다. |



```c++
int x = 0; //변수의 닉네임을 x라고 설정
int &y = &x; //닉네임이 x라는 변수는  y라는 닉네임으로도 하겠다 (Reference는 변수의 닉네임이 새로 생겼다 라는 의미로 가능)
int *z = &x; //int* 자료형에 x의 주소값을 저장
```



```c++
int* - int를 가리키는 포인터
int const * - const int를 가리키는 포인터
int * const - int를 가리키는 const 포인터
int const * const - const int를 가리키는 const 포인터
```



operator

```c++
//opertators는 함수로 보는것이 좋다.
```

## Class

클래스란 cpp에서 데이터 구조의 컨셉과 같은 확장 된 개념입니다. 데이터 구조 처럼 데이터 멤버를 포함 할 수 있지만, 함수를 멤버로 포함 할 수도 있습니다.

객체는 클래스의 인스턴스입니다. 변수의 관점에서는 클래스는 유형이되고 객체는 변수가 됩니다.



클래스는 키워드 `class` 또는  키워드 `struct` 사용하여 다음 정의 됩니다.

```c++
class class_name {
  access_specifier_1:
    member1;
  access_specifier_2:
    member2;
  ...
} object_names;
```



클래스는 함수를 포함 할 수 있고 엑세스 지정자 라는 새로운 기능을 가질 수있다는 점을 제외하면 데이터 구조와

형식이 동일합니다. 엑세스 지정은 키워드`private`, `public`, `protected` 로 엑세스 권한으 수정합니다.



---

참고

https://en.cppreference.com/w/

http://www.cplusplus.com/



## CPU 간단 소개

CPU 는 말했듯이 컴퓨터의 모든 연산이 발생하는 두뇌 라고 볼 수 있습니다. CPU 에서 연산을 수행하기 위해서는, CPU 의 **레지스터(register)** 라는 곳에 데이터를 기록한 다음에 연산을 수행해야 합니다.



레지스터의 크기는 매우 작습니다. 64 비트 컴퓨터의 경우, 레지스터의 크기들이 8 바이트에 비해 불과합니다. 뿐만 아니라 레지스터의 개수는 그리 많지 않습니다. 일반적인 연산에서 사용되는 범용 레지스터의 경우 불과 16 개 밖에 없습니다

## 정리 해보기, 테스트 코드

### 복사생성자 (깊은복사, 얕은복사)



### mutable

### Null Pointer

```c++
int main(){
	double *ptr = nullptr; //modern c++
	
	if(ptr != nullptr)
	{
		//do something usefull
	}
	else
	{
		//do nothing with ptr
	}
    
    std::nullptr_t nptr; //타입 널포인트만 할당할수 있다, 간혹 파라미터 중에 널 포인터만 받을때 사용한다
	
	return 0;
}
```



### 

### 



# CMake

CMake는 Make보다 Makefile의 다소 지저분한 루틴들을 추상화(Abstraction)해서 보다 직관적으로 빌드 과정을 기술해주는 것입니다. 즉, CMake는 Makefile을 보다 쉽게 기술해 주는 일종의 Meta-Makefile이라고 할 수 있습니다. CMake로 프로젝트를 관리하더라도 결국 최종 빌드는 Make와 마찬가지로 make 명령으로 수행합니다.



Makefile에서는 빌드 간생성물인 Object파일들의 이름과 의존성 정보까지 모두 기술해 줘야 하지만, CMake에서는 그럴 필요가 전혀 없습니다. 뒤에서 살펴보겠지만, CMake의 빌드 스크립트인 CMakeLists.txt에서는 **최종 빌드 결과물**과 이를 빌드하기 위한 **소스 파일**들만 명시해 주면 그것으로 끝입니다. (여기서 최종 빌드 결과물은 실행 바이너리나 라이브러리가 됩니다.)



CMake를 사용하면 의존성 정보를 일일이 기술해 주지 않아도 되므로 빌드 스크립트의 관리 측면에서 매우 효율적입니다. 프로젝트를 처음 시작할 때 Build Step만 잘 구성해 놓으면, 이후에는 소스 파일(*.c)을 처음 추가할 때만 CMakeLists.txt 파일을 열어서 등록해 주면 됩니다. (그다지 추천하는 방법은 아니지만, 소스파일을 자동으로 찾아서 추가하도록 구성하는 방법도 있습니다.) 이후에는 소스코드를 어떻게 수정하더라도 빌드에서 제외하지 않는 한 스크립트를 수정하지 않아도 됩니다.



Makefile에서는 빌드 중간생성물인 Object파일들의 이름과 의존성 정보까지 모두 기술해 줘야 하지만

명령어

```
gcc -c -o main.o main.c
gcc -c -o foo.o foo.c
gcc -c -o bar.o bar.c


gcc -o app.out main.o foo.o bar.o
```

`MakeFile`

```makefile
OBJS=main.o foo.o bar.o
TARGET=app.out
 
all: $(TARGET)
  
clean:
    rm -f *.o
    rm -f $(TARGET)
 
$(TARGET): $(OBJS)
    $(CC) -o $@ $(OBJS)
  
main.o: foo.h bar.h main.c
foo.o: foo.h foo.c
bar.o: bar.h bar.c
```



 CMake에서는 그럴 필요가 전혀 없습니다. CMake의 빌드 스크립트인 CMakeLists.txt에서는 **최종 빌드 결과물**과 이를 빌드하기 위한 **소스 파일**들만 명시해 주면 그것으로 끝입니다. (여기서 최종 빌드 결과물은 실행 바이너리나 라이브러리가 됩니다.)

`CmakeLists.txt`

```cmake
ADD_EXECUTABLE( app.out main.c foo.c bar.c )
```

그 외에 CMake로 프로젝트를 관리하면 CLion이나 Eclipse와 같은 범용 IDE에서 프로젝트 설정 파일로 사용할 수 있다는 장점도 있습니다. 따라서 협업 프로젝트에서 프로젝트를 체계적으로 관리하면서도 각 개발자마다 선호하는 개발 환경에서 작업을 할 수 있습니다.



# 리눅스 명령어

- ls
- ll
- cat
- sort
- head
- tail
- uniq

