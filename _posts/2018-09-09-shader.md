---
layout: post
title: "01. Shader기본동작원리"
description: 01.쉐이더 기본동작 원리
image: '\images\bg.jpg'
category: 'blog'
tag:
 - Shader
 - Unity3D
introduction: 쉐이더 기본동작 원리
---

# 3D Graphics Rendering Pipeline

![pipeline](\images\pipeline.png)

기본적인 렌더링 파이프라인 (조금 씩 GPU마다 다를수있습니다)  동작원리

------



# Shader

**쉐이더란 화면에 출력할 픽셀의 위치와 색상을 계산하는 함수**

**쉐이더는 픽셀의 농담, 색조, 명암을 결정한다.**





# Vertex Shader(정점 쉐이더)



![vertex-shader-anim](\images\vertex-shader-anim.gif)

Vertex Shader 는 3D 모델의 각 버텍스에서 실행되는 프로그램입니다. 많은 경우 버텍스 셰이더는 특별히 흥미로운 동작을 하지는 않습니다. 여기서는 버텍스 위치를 오브젝트 공간에서 이른바 “클립 공간”으로 변환하기만 합니다. GPU 가 오브젝트를 화면에 래스터화하기 위해 클립 공간을 사용합니다. 프래그먼트 셰이더에서 텍스처를 샘플링하기 위해 필요로 합니다.

**출처 : webglfundamentals.org**

------





# Rasterizer(레스터라이저)

래스터라이저는 뷰에 없는 기본 요소를 잘라내고, PS(픽셀 셰이더) 단계에 대해 기본 요소를 준비하고, 픽셀 셰이더를 호출하는 방법을 결정합니다.

------





# Fragment Shader(프래그멘트 쉐이더)

![fragmentAnim](\images\fragmentAnim.gif)

Fragment Shader는 오브젝트가 화면에서 차지하고 있는 모든 픽셀마다 실행되는 프로그램이며 보통 각 픽셀의 컬러를 계산하고 출력하기 위해 사용됩니다. 화면에는 보통 수백만 개의 픽셀이 있으며 프래그먼트 셰이더는 이 모든 픽셀에 대해 실행됩니다! 프래그먼트 셰이더를 최적화하는 것은 전반적인 게임 성능에 있어 매우 중요한 부분입니다.

**출처 : webglfundamentals.org**

------





기본적인 기능 : 색깔 바꾸기, 텍스쳐링,  색상합성,  버텍스 컬러, 버텍스 애니메이션,  프레넬,  노이즈맵

텍스쳐 uv,  스케일링,  맵핑 위치 바꾸기, 텍스쳐 마스킹,  렌더 텍스쳐, 그림자, 

------









# Semantic(시멘틱)

POSITION : 로컬 좌표의  정점 위치

POSITONT : 변환된 정점 위치

TAGENT : 법선

TEXCOORD : 텍스쳐 좌표

COLOR :  컬러

VFACE : 렌더링된 면이 앞면인지 뒷면인지 판별

------



# 텍스쳐(Texture)

```c++
Shader "TextureRotate" {

	Properties {
		[HDR]_Color ("Color", Color) = (1,1,1,1)
		_MainTex ("Albedo (RGB)", 2D) = "white" {}
		_RotationSpeed("_RotationSpeed (텍스처 회전속도)", Range(0, 10)) = 1
	}

	SubShader {

		Tags { "RenderType"="Transparent" "Queue" = "Transparent"}

		LOD 200

		CGPROGRAM


		#pragma surface surf Lambert alpha:fade vertex:vert
		#pragma target 2.0

		sampler2D _MainTex;
		struct Input {

			fixed2 uv_MainTex;

		};

		fixed4 _Color;
		fixed _ViewAmount; //보이는 정도
		float _RotationSpeed; //텍스처 회전 속도

		void vert(inout appdata_base v) {

			float2 pivot = float2(0.5, 0.5); //텍스처 전체의 피봇을 0.5만큼 더함.

			//Angle 반지름이 1인 원에서 삼각함수를 이용하여 (x,y) 좌표를 구할줄 알면 밑에 코드를 이해 할수 있다
			float sinAngle = sin(_RotationSpeed);
			float cosAngle = cos(_RotationSpeed);

			float2x2 rotationMatrix = float2x2(cosAngle, -sinAngle, sinAngle, cosAngle);

			v.texcoord.xy = mul(rotationMatrix, v.texcoord.xy - pivot) + pivot; 
            //피봇 값을 빼고 더한이유는 텍스쳐는 0,0.좌표가 왼쪽하단이거나, 왼쪽상단이다
            //중심은 (0.5, 0.5)이고 회전할때는 0,0 좌표 중심으로 회전시키기 때문에 
            //텍스쳐 좌표를 피벗값을 마이너스 하여 중심을 0,0으로 맞추어 회전 시킨다음 다시 피봇값을 더 한다

		}

		////https://forum.unity.com/threads/rotation-of-texture-uvs-directly-from-a-shader.150482/



		void surf (Input IN, inout SurfaceOutput o) {

			fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;

			o.Emission = c;

			o.Alpha = c.a;

		}

		ENDCG

	}
}
```

